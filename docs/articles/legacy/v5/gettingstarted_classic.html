<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title> | Apizr </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=" | Apizr ">
      
      
      <link rel="icon" href="../../../resources/favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Respawnsive/Apizr/blob/dev/Apizr/Docs/Apizr.Docs/articles/legacy/v5/gettingstarted_classic.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../resources/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<h2 id="defining">Defining</h2>
<p>We could define our web api service just like:</p>
<pre><code class="lang-csharp">[assembly:Policy(&quot;TransientHttpError&quot;)]
namespace Apizr.Sample
{
    [WebApi(&quot;https://reqres.in/&quot;), Cache, Log]
    public interface IReqResService
    {
        [Get(&quot;/api/users&quot;)]
        Task&lt;UserList&gt; GetUsersAsync();

        [Get(&quot;/api/users/{userId}&quot;)]
        Task&lt;UserDetails&gt; GetUserAsync([CacheKey] int userId);

        [Post(&quot;/api/users&quot;)]
        Task&lt;User&gt; CreateUser(User user);
    }
}
</code></pre>
<p>And that's all.</p>
<p>Every attributes here will inform Apizr on how to manage each web api request. No more boilerplate.</p>
<p>Actually, you should consider to add a special parameter called RequestOptions to each methods, allowing some option adjustments later at request time:</p>
<pre><code class="lang-csharp">[assembly:Policy(&quot;TransientHttpError&quot;)]
namespace Apizr.Sample
{
    [WebApi(&quot;https://reqres.in/&quot;), Cache, Log]
    public interface IReqResService
    {
        [Get(&quot;/api/users&quot;)]
        Task&lt;UserList&gt; GetUsersAsync([RequestOptions] IApizrRequestOptions options);

        [Get(&quot;/api/users/{userId}&quot;)]
        Task&lt;UserDetails&gt; GetUserAsync([CacheKey] int userId, 
            [RequestOptions] IApizrRequestOptions options);

        [Post(&quot;/api/users&quot;)]
        Task&lt;User&gt; CreateUser(User user, 
            [RequestOptions] IApizrRequestOptions options);
    }
}
</code></pre>
<h2 id="registering">Registering</h2>
<p>It's not required to register anything in a container for DI purpose (you can use the returned static instance directly), but we'll describe here how to use it with DI anyway.</p>
<h3 id="registering-a-single-interface">Registering a single interface</h3>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_tabid-static" role="tab" aria-controls="tabpanel_1_tabid-static" data-tab="tabid-static" tabindex="0" aria-selected="true">Static</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_tabid-extended" role="tab" aria-controls="tabpanel_1_tabid-extended" data-tab="tabid-extended" tabindex="-1">Extended</a>
</li>
</ul>
<section id="tabpanel_1_tabid-static" role="tabpanel" data-tab="tabid-static">

<p>Here is an example of how to register a managed instance of an api interface:</p>
<pre><code class="lang-csharp">// Some policies
var registry = new PolicyRegistry
{
    {
        &quot;TransientHttpError&quot;, 
        HttpPolicyExtensions
            .HandleTransientHttpError()
            .WaitAndRetryAsync(new[]
        {
            TimeSpan.FromSeconds(1),
            TimeSpan.FromSeconds(5),
            TimeSpan.FromSeconds(10)
        })
    }
};

// Apizr registration
myContainer.RegistrationMethodFactory(() =&gt; 
    ApizrBuilder.Current.CreateManagerFor&lt;IReqResService&gt;(options =&gt; options
        .WithPolicyRegistry(registry)
        .WithAkavacheCacheHandler())
);
</code></pre>
<p>We provided a policy registry and a cache handler here as we asked for it with cache and policy attributes while designing the api interface.
Also, you could use the manager directly instead of registering it.</p>
</section>
<section id="tabpanel_1_tabid-extended" role="tabpanel" data-tab="tabid-extended" aria-hidden="true" hidden="hidden">

<p>Here is an example of how to register a managed api interface:</p>
<pre><code class="lang-csharp">public override void ConfigureServices(IServiceCollection services)
{
    // Some policies
    var registry = new PolicyRegistry
    {
        {
            &quot;TransientHttpError&quot;, 
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .WaitAndRetryAsync(new[]
            {
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(5),
                TimeSpan.FromSeconds(10)
            })
        }
    };
    services.AddPolicyRegistry(registry);

    // Apizr registration
    services.AddApizrManagerFor&lt;IReqResService&gt;(options =&gt; options.WithAkavacheCacheHandler());
}
</code></pre>
<p>We registered a policy registry and provided a cache handler here as we asked for it with cache and policy attributes while designing the api interface.</p>
</section>
</div>
<h3 id="registering-multiple-interfaces">Registering multiple interfaces</h3>
<p>You may want to register multiple managed api interfaces within the same project.
Also, you may want to share some common configuration between apis without repeating yourself, but at the same time, you may need to set some specific ones for some of it.
This is where the ApizrRegistry comes on stage.</p>
<h4 id="single-common-configuration">Single common configuration</h4>
<p>Here is an example of how to register a managed instance of multiple api interfaces, sharing a single common configuration:</p>
<div class="tabGroup" id="tabgroup_2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_2_tabid-static" role="tab" aria-controls="tabpanel_2_tabid-static" data-tab="tabid-static" tabindex="0" aria-selected="true">Static</a>
</li>
<li role="presentation">
<a href="#tabpanel_2_tabid-extended" role="tab" aria-controls="tabpanel_2_tabid-extended" data-tab="tabid-extended" tabindex="-1">Extended</a>
</li>
</ul>
<section id="tabpanel_2_tabid-static" role="tabpanel" data-tab="tabid-static">

<pre><code class="lang-csharp">// Some policies
var registry = new PolicyRegistry
{
    {
        &quot;TransientHttpError&quot;, 
        HttpPolicyExtensions
            .HandleTransientHttpError()
            .WaitAndRetryAsync(new[]
        {
            TimeSpan.FromSeconds(1),
            TimeSpan.FromSeconds(5),
            TimeSpan.FromSeconds(10)
        })
    }
};

// Apizr registry
var apizrRegistry = ApizrBuilder.Current.CreateRegistry(
    registry =&gt; registry
        .AddManagerFor&lt;IReqResService&gt;()
        .AddManagerFor&lt;IHttpBinService&gt;(
            options =&gt; options
                .WithLogging(
                    HttpTracerMode.Everything, 
                    HttpMessageParts.All, 
                    LogLevel.Trace)),
    
    config =&gt; config
        .WithPolicyRegistry(registry)
        .WithAkavacheCacheHandler()
        .WithLogging(
            HttpTracerMode.ExceptionsOnly, 
            HttpMessageParts.ResponseAll, 
            LogLevel.Error)
);

// Container registration
apizrRegistry.Populate((type, factory) =&gt; 
    myContainer.RegistrationMethodFactory(type, factory)
);
</code></pre>
<p>Here is what we're saying in this example:</p>
<ul>
<li>Add a manager for IReqResService api interface into the registry</li>
<li>Add a manager for IHttpBinService api interface into the registry
<ul>
<li>Set some specific logging settings dedicated to IHttpBinService's manager</li>
</ul>
</li>
<li>Apply common configuration to all managers by:
<ul>
<li>Providing a policy registry</li>
<li>Providing a cache handler</li>
<li>Providing some logging settings (won't apply to IHttpBinService's manager as we set some specific ones)</li>
</ul>
</li>
</ul>
<p>It's an example, meaning if you don't need common and/or specific configuration, just don't provide it.
And yes you can mix classic and CRUD manager registration into the same registry.</p>
<p>Also, you could register the registry itslef, instead of its populated managers and then use its managers directly.</p>
<p>Or, you could use the managers directly from the registry instead of registering anything.</p>
</section>
<section id="tabpanel_2_tabid-extended" role="tabpanel" data-tab="tabid-extended" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public override void ConfigureServices(IServiceCollection services)
{
    // Some policies
    var registry = new PolicyRegistry
    {
        {
            &quot;TransientHttpError&quot;, 
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .WaitAndRetryAsync(new[]
            {
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(5),
                TimeSpan.FromSeconds(10)
            })
        }
    };
    services.AddPolicyRegistry(registry);

    // Apizr registration
    services.AddApizr(
        registry =&gt; registry
            .AddManagerFor&lt;IReqResService&gt;()
            .AddManagerFor&lt;IHttpBinService&gt;(
                options =&gt; options
                    .WithLogging(
                        HttpTracerMode.Everything, 
                        HttpMessageParts.All, 
                        LogLevel.Trace)),
    
        config =&gt; config
            .WithPolicyRegistry(registry)
            .WithAkavacheCacheHandler()
            .WithLogging(
                HttpTracerMode.ExceptionsOnly, 
                HttpMessageParts.ResponseAll, 
                LogLevel.Error)
    );
}
</code></pre>
<p>Here is what we're saying in this example:</p>
<ul>
<li>Add a manager for IReqResService api interface into the registry, to register it into the container</li>
<li>Add a manager for IHttpBinService api interface into the registry, to register it into the container
<ul>
<li>Set some specific logging settings dedicated to IHttpBinService's manager</li>
</ul>
</li>
<li>Apply common configuration to all managers by:
<ul>
<li>Providing a policy registry</li>
<li>Providing a cache handler</li>
<li>Providing some logging settings (won't apply to IHttpBinService's manager as we set some specific ones)</li>
</ul>
</li>
</ul>
<p>It's an example, meaning if you don't need common and/or specific configuration, just don't provide it.
And yes you can mix classic and CRUD manager registration into the same registry.</p>
<p>Of course, each managers will be regitered into the container so that you can use it directly.</p>
<p>Also, the registry itslef will be registered into the container, so you could resolve it to get its managers, instead of resolving each managers.</p>
</section>
</div>

<p>Here is how to get a manager from the registry:</p>
<pre><code class="lang-csharp">var reqResManager = apizrRegistry.GetManagerFor&lt;IReqResService&gt;();

var httpBinManager = apizrRegistry.GetManagerFor&lt;IHttpBinService&gt;();
</code></pre>
<h4 id="multiple-common-configurations">Multiple common configurations</h4>
<p>Here is an example of how to register a managed instance of multiple api interfaces, sharing multiple common configurations at different group level.
It could be usefull when requesting mutliple apis (multiple base address) comming with multiple endpoints (multiple base path).</p>
<div class="tabGroup" id="tabgroup_3">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_3_tabid-static" role="tab" aria-controls="tabpanel_3_tabid-static" data-tab="tabid-static" tabindex="0" aria-selected="true">Static</a>
</li>
<li role="presentation">
<a href="#tabpanel_3_tabid-extended" role="tab" aria-controls="tabpanel_3_tabid-extended" data-tab="tabid-extended" tabindex="-1">Extended</a>
</li>
</ul>
<section id="tabpanel_3_tabid-static" role="tabpanel" data-tab="tabid-static">

<pre><code class="lang-csharp">// Some policies
var registry = new PolicyRegistry
{
    {
        &quot;TransientHttpError&quot;, 
        HttpPolicyExtensions
            .HandleTransientHttpError()
            .WaitAndRetryAsync(new[]
        {
            TimeSpan.FromSeconds(1),
            TimeSpan.FromSeconds(5),
            TimeSpan.FromSeconds(10)
        })
    }
};

// Apizr registry
var apizrRegistry = ApizrBuilder.Current.CreateRegistry(
    registry =&gt; registry
        .AddGroup(
            group =&gt; group
                .AddManagerFor&lt;IReqResUserService&gt;(
                    config =&gt; config.WithBasePath(&quot;users&quot;))
                .AddManagerFor&lt;IReqResResourceService&gt;(
                    config =&gt; config.WithBasePath(&quot;resources&quot;)),
            config =&gt; config.WithBaseAddress(&quot;https://reqres.in/api&quot;))

        .AddManagerFor&lt;IHttpBinService&gt;(
            config =&gt; config.WithBaseAddress(&quot;https://httpbin.org&quot;)),
    
    config =&gt; config
        .WithPolicyRegistry(registry)
        .WithAkavacheCacheHandler()
        .WithLogging(HttpTracerMode.ExceptionsOnly, HttpMessageParts.ResponseAll, LogLevel.Error)
);

// Container registration
apizrRegistry.Populate((type, factory) =&gt; 
    myContainer.RegistrationMethodFactory(type, factory)
);
</code></pre>
<p>Here is what we're saying in this example:</p>
<ul>
<li>Add a manager for IReqResUserService api interface into the registry with a common base address (<a href="https://reqres.in/api">https://reqres.in/api</a>) and a specific base path (users)</li>
<li>Add a manager for IReqResResourceService api interface into the registry with a common base address (<a href="https://reqres.in/api">https://reqres.in/api</a>) and a specific base path (resources)</li>
<li>Add a manager for IHttpBinService api interface into the registry with a speific base address (<a href="https://httpbin.org">https://httpbin.org</a>)</li>
<li>Apply common configuration to all managers by:
<ul>
<li>Providing a policy registry</li>
<li>Providing a cache handler</li>
<li>Providing some logging settings</li>
</ul>
</li>
</ul>
<p>It's an example, meaning if you don't need common and/or specific configuration, just don't provide it.
And yes you can mix classic and CRUD manager registration into the same registry/group.
You can add mutliple group at the same level and go deeper with group into group itself.</p>
<p>Also, you could register the registry itslef, instead of its populated managers and then use its managers directly.</p>
<p>Or, you could use the managers directly from the registry instead of registering anything.</p>
</section>
<section id="tabpanel_3_tabid-extended" role="tabpanel" data-tab="tabid-extended" aria-hidden="true" hidden="hidden">

<pre><code class="lang-csharp">public override void ConfigureServices(IServiceCollection services)
{
    // Some policies
    var registry = new PolicyRegistry
    {
        {
            &quot;TransientHttpError&quot;, 
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .WaitAndRetryAsync(new[]
            {
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(5),
                TimeSpan.FromSeconds(10)
            })
        }
    };
    services.AddPolicyRegistry(registry);

    // Apizr registration
    services.AddApizr(
        registry =&gt; registry
            .AddGroup(
                group =&gt; group
                    .AddManagerFor&lt;IReqResUserService&gt;(
                        config =&gt; config.WithBasePath(&quot;users&quot;))
                    .AddManagerFor&lt;IReqResResourceService&gt;(
                        config =&gt; config.WithBasePath(&quot;resources&quot;)),
                config =&gt; config.WithBaseAddress(&quot;https://reqres.in/api&quot;))

            .AddManagerFor&lt;IHttpBinService&gt;(
                config =&gt; config.WithBaseAddress(&quot;https://httpbin.org&quot;)),
    
        config =&gt; config
            .WithPolicyRegistry(registry)
            .WithAkavacheCacheHandler()
            .WithLogging(
                HttpTracerMode.ExceptionsOnly, 
                HttpMessageParts.ResponseAll, 
                LogLevel.Error)
    );
}
</code></pre>
<p>Here is what we're saying in this example:</p>
<ul>
<li>Add a manager for IReqResUserService api interface into the registry with a common base address (<a href="https://reqres.in/api">https://reqres.in/api</a>) and a specific base path (users), to register it into the container</li>
<li>Add a manager for IReqResResourceService api interface into the registry with a common base address (<a href="https://reqres.in/api">https://reqres.in/api</a>) and a specific base path (resources), to register it into the container</li>
<li>Add a manager for IHttpBinService api interface into the registry with a speific base address (<a href="https://httpbin.org">https://httpbin.org</a>), to register it into the container</li>
<li>Apply common configuration to all managers by:
<ul>
<li>Providing a policy registry</li>
<li>Providing a cache handler</li>
<li>Providing some logging settings</li>
</ul>
</li>
</ul>
<p>It's an example, meaning if you don't need common and/or specific configuration, just don't provide it.
And yes you can mix classic and CRUD manager registration into the same registry.
You can add mutliple group at the same level and go deeper with group into group itself.</p>
<p>Of course, each managers will be regitered into the container so that you can use it directly.</p>
<p>Also, the registry itslef will be registered into the container, so you could use it to get its managers, instead of using each managers.</p>
</section>
</div>

<p>Here's how to get a manager from the registry:</p>
<pre><code class="lang-csharp">var reqResUserManager = apizrRegistry.GetManagerFor&lt;IReqResUserService&gt;();

var reqResResourceManager = apizrRegistry.GetManagerFor&lt;IReqResResourceService&gt;();

var httpBinManager = apizrRegistry.GetManagerFor&lt;IHttpBinService&gt;();
</code></pre>
<h3 id="registering-all-scanned-interfaces">Registering all scanned interfaces</h3>
<div class="tabGroup" id="tabgroup_4">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_4_tabid-static" role="tab" aria-controls="tabpanel_4_tabid-static" data-tab="tabid-static" tabindex="0" aria-selected="true">Static</a>
</li>
<li role="presentation">
<a href="#tabpanel_4_tabid-extended" role="tab" aria-controls="tabpanel_4_tabid-extended" data-tab="tabid-extended" tabindex="-1">Extended</a>
</li>
</ul>
<section id="tabpanel_4_tabid-static" role="tabpanel" data-tab="tabid-static">

<p>Not available.</p>
</section>
<section id="tabpanel_4_tabid-extended" role="tabpanel" data-tab="tabid-extended" aria-hidden="true" hidden="hidden">

<p>Here is an example of how to auto register all scanned interfaces:</p>
<pre><code class="lang-csharp">public override void ConfigureServices(IServiceCollection services)
{
    // Some policies
    var registry = new PolicyRegistry
    {
        {
            &quot;TransientHttpError&quot;, 
            HttpPolicyExtensions
                .HandleTransientHttpError()
                .WaitAndRetryAsync(new[]
            {
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(5),
                TimeSpan.FromSeconds(10)
            })
        }
    };
    services.AddPolicyRegistry(registry);

    // Apizr registration
    services.AddApizrManagerFor(options =&gt; options.WithAkavacheCacheHandler(), ASSEMBLIES_CONTAINING_INTERFACES);
}
</code></pre>
<p>Apizr will scan assemblies to auto register managers for decorated api interfaces.</p>
<p>We registered a policy registry and provided a cache handler here as we asked for it with cache and policy attributes while designing the api interface.</p>
</section>
</div>
<h2 id="using">Using</h2>
<p>Here is an example of how to send a web request from an app - e.g. using Apizr in a Xamarin.Forms mobile app.</p>
<p>Inject <code>IApizrManager&lt;IYourDefinedInterface&gt;</code> where you need it - e.g. into your ViewModel constructor</p>
<pre><code class="lang-csharp">public class YourViewModel
{
    private readonly IApizrManager&lt;IReqResService&gt; _reqResManager;
    //private readonly IApizrRegistry _apizrRegistry;
	
    public YouViewModel(IApizrManager&lt;IReqResService&gt; reqResManager)
    // OR registry injection
    //public YouViewModel(IApizrRegistry apizrRegistry)
    {
        _reqResManager = reqResManager;

        // OR registry injection
        //_apizrRegistry = apizrRegistry;

        // Or registry injection AND getting the manager
        //_reqResManager = apizrRegistry.GetManagerFor&lt;IReqResService&gt;();
    }
    
    public ObservableCollection&lt;User&gt;? Users { get; set; }

    private async Task GetUsersAsync()
    {
        IList&lt;User&gt;? users;
        try
        {
            var userList = await _reqResManager.ExecuteAsync(api =&gt; api.GetUsersAsync()); 

            // OR with dedicated registry shortcut extension
            // var userList = await _apizrRegistry.ExecuteAsync&lt;IReqResService&gt;(api =&gt; api.GetUsersAsync());
 
            // OR with some option adjustments
            // var userList = await _reqResManager.ExecuteAsync((options, api) =&gt; api.GetUsersAsync(options),
            //                  options =&gt; options.WithPriority(Priority.Background)); 

            users = userList.Data;
        }
        catch (ApizrException&lt;UserList&gt; e)
        {
            var message = e.InnerException is IOException ? &quot;No network&quot; : (e.Message ?? &quot;Error&quot;);
            UserDialogs.Instance.Toast(new ToastConfig(message) { BackgroundColor = Color.Red, MessageTextColor = Color.White });

            users = e.CachedResult?.Data;
        }

        if(users != null)
            Users = new ObservableCollection&lt;User&gt;(users);
    }
}
</code></pre>
<p>We catch any ApizrException as it will contain the original inner exception, but also the previously cached result if some.
If you provided an IConnectivityHandler implementation and there's no network connectivity before sending request, Apizr will throw an IO inner exception without sending the request.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Respawnsive/Apizr/blob/dev/Apizr/Docs/Apizr.Docs/articles/legacy/v5/gettingstarted_classic.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Supported by Respawnsive
        </div>
      </div>
    </footer>
  </body>
</html>
